/*
 * Twilio - Media
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.30.0
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for passing parameters to the method [`create_media_processor`]
#[derive(Clone, Debug, Default)]
pub struct CreateMediaProcessorParams {
    /// The [Media Extension](/docs/live/api/media-extensions-overview) name or URL. Ex: `video-composer-v2`
    pub extension: String,
    /// The context of the Media Extension, represented as a JSON dictionary. See the documentation for the specific [Media Extension](/docs/live/api/media-extensions-overview) you are using for more information about the context to send.
    pub extension_context: String,
    /// User-defined environment variables for the Media Extension, represented as a JSON dictionary of key/value strings. See the documentation for the specific [Media Extension](/docs/live/api/media-extensions-overview) you are using for more information about whether you need to provide this.
    pub extension_environment: Option<serde_json::Value>,
    /// The maximum time, in seconds, that the MediaProcessor can run before automatically ends. The default value is 300 seconds, and the maximum value is 90000 seconds. Once this maximum duration is reached, Twilio will end the MediaProcessor, regardless of whether media is still streaming.
    pub max_duration: Option<i32>,
    /// The URL to which Twilio will send asynchronous webhook requests for every MediaProcessor event. See [Status Callbacks](/docs/live/status-callbacks) for details.
    pub status_callback: Option<String>,
    /// The HTTP method Twilio should use to call the `status_callback` URL. Can be `POST` or `GET` and the default is `POST`.
    pub status_callback_method: Option<String>,
}

/// struct for passing parameters to the method [`create_player_streamer`]
#[derive(Clone, Debug, Default)]
pub struct CreatePlayerStreamerParams {
    /// The maximum time, in seconds, that the PlayerStreamer can run before automatically ends. The default value is 300 seconds, and the maximum value is 90000 seconds. Once this maximum duration is reached, Twilio will end the PlayerStreamer, regardless of whether media is still streaming.
    pub max_duration: Option<i32>,
    /// The URL to which Twilio will send asynchronous webhook requests for every PlayerStreamer event. See [Status Callbacks](/docs/live/status-callbacks) for more details.
    pub status_callback: Option<String>,
    /// The HTTP method Twilio should use to call the `status_callback` URL. Can be `POST` or `GET` and the default is `POST`.
    pub status_callback_method: Option<String>,
    /// Specifies whether the PlayerStreamer is configured to stream video. Defaults to `true`.
    pub video: Option<bool>,
}

/// struct for passing parameters to the method [`create_player_streamer_playback_grant`]
#[derive(Clone, Debug, Default)]
pub struct CreatePlayerStreamerPlaybackGrantParams {
    /// The unique string generated to identify the PlayerStreamer resource associated with this PlaybackGrant
    pub sid: String,
    /// The full origin URL where the livestream can be streamed. If this is not provided, it can be streamed from any domain.
    pub access_control_allow_origin: Option<String>,
    /// The time to live of the PlaybackGrant. Default value is 15 seconds. Maximum value is 60 seconds.
    pub ttl: Option<i32>,
}

/// struct for passing parameters to the method [`delete_media_recording`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMediaRecordingParams {
    /// The SID of the MediaRecording resource to delete.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_media_processor`]
#[derive(Clone, Debug, Default)]
pub struct FetchMediaProcessorParams {
    /// The SID of the MediaProcessor resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_media_recording`]
#[derive(Clone, Debug, Default)]
pub struct FetchMediaRecordingParams {
    /// The SID of the MediaRecording resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_player_streamer`]
#[derive(Clone, Debug, Default)]
pub struct FetchPlayerStreamerParams {
    /// The SID of the PlayerStreamer resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_player_streamer_playback_grant`]
#[derive(Clone, Debug, Default)]
pub struct FetchPlayerStreamerPlaybackGrantParams {
    /// The SID of the PlayerStreamer resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`list_media_processor`]
#[derive(Clone, Debug, Default)]
pub struct ListMediaProcessorParams {
    /// The sort order of the list by `date_created`. Can be: `asc` (ascending) or `desc` (descending) with `desc` as the default.
    pub order: Option<String>,
    /// Status to filter by, with possible values `started`, `ended` or `failed`.
    pub status: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_media_recording`]
#[derive(Clone, Debug, Default)]
pub struct ListMediaRecordingParams {
    /// The sort order of the list by `date_created`. Can be: `asc` (ascending) or `desc` (descending) with `desc` as the default.
    pub order: Option<String>,
    /// Status to filter by, with possible values `processing`, `completed`, `deleted`, or `failed`.
    pub status: Option<String>,
    /// SID of a MediaProcessor to filter by.
    pub processor_sid: Option<String>,
    /// SID of a MediaRecording source to filter by.
    pub source_sid: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_player_streamer`]
#[derive(Clone, Debug, Default)]
pub struct ListPlayerStreamerParams {
    /// The sort order of the list by `date_created`. Can be: `asc` (ascending) or `desc` (descending) with `desc` as the default.
    pub order: Option<String>,
    /// Status to filter by, with possible values `created`, `started`, `ended`, or `failed`.
    pub status: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`update_media_processor`]
#[derive(Clone, Debug, Default)]
pub struct UpdateMediaProcessorParams {
    /// The SID of the MediaProcessor resource to update.
    pub sid: String,
    /// The status of the MediaProcessor. Can be `ended`.
    pub status: String,
}

/// struct for passing parameters to the method [`update_player_streamer`]
#[derive(Clone, Debug, Default)]
pub struct UpdatePlayerStreamerParams {
    /// The SID of the PlayerStreamer resource to update.
    pub sid: String,
    /// The status the PlayerStreamer should be transitioned to. Can be: `ended`.
    pub status: String,
}

/// struct for typed successes of method [`create_media_processor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMediaProcessorSuccess {
    Status201(crate::models::MediaV1MediaProcessor),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_player_streamer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePlayerStreamerSuccess {
    Status201(crate::models::MediaV1PlayerStreamer),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_player_streamer_playback_grant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePlayerStreamerPlaybackGrantSuccess {
    Status201(crate::models::MediaV1PlayerStreamerPlayerStreamerPlaybackGrant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_media_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMediaRecordingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_media_processor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMediaProcessorSuccess {
    Status200(crate::models::MediaV1MediaProcessor),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_media_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMediaRecordingSuccess {
    Status200(crate::models::MediaV1MediaRecording),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_player_streamer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchPlayerStreamerSuccess {
    Status200(crate::models::MediaV1PlayerStreamer),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_player_streamer_playback_grant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchPlayerStreamerPlaybackGrantSuccess {
    Status200(crate::models::MediaV1PlayerStreamerPlayerStreamerPlaybackGrant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_media_processor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMediaProcessorSuccess {
    Status200(crate::models::ListMediaProcessorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_media_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMediaRecordingSuccess {
    Status200(crate::models::ListMediaRecordingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_player_streamer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPlayerStreamerSuccess {
    Status200(crate::models::ListPlayerStreamerResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_media_processor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMediaProcessorSuccess {
    Status200(crate::models::MediaV1MediaProcessor),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_player_streamer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePlayerStreamerSuccess {
    Status200(crate::models::MediaV1PlayerStreamer),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_media_processor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMediaProcessorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_player_streamer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePlayerStreamerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_player_streamer_playback_grant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePlayerStreamerPlaybackGrantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_media_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMediaRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_media_processor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMediaProcessorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_media_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMediaRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_player_streamer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchPlayerStreamerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_player_streamer_playback_grant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchPlayerStreamerPlaybackGrantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_media_processor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMediaProcessorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_media_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMediaRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_player_streamer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPlayerStreamerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_media_processor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMediaProcessorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_player_streamer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePlayerStreamerError {
    UnknownValue(serde_json::Value),
}

///
pub async fn create_media_processor(
    configuration: &configuration::Configuration,
    params: CreateMediaProcessorParams,
) -> Result<ResponseContent<CreateMediaProcessorSuccess>, Error<CreateMediaProcessorError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let extension = params.extension;
    let extension_context = params.extension_context;
    let extension_environment = params.extension_environment;
    let max_duration = params.max_duration;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/MediaProcessors", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Extension", extension.to_string());
    local_var_form_params.insert("ExtensionContext", extension_context.to_string());
    if let Some(local_var_param_value) = extension_environment {
        local_var_form_params.insert("ExtensionEnvironment", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = max_duration {
        local_var_form_params.insert("MaxDuration", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMediaProcessorSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMediaProcessorError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn create_player_streamer(
    configuration: &configuration::Configuration,
    params: CreatePlayerStreamerParams,
) -> Result<ResponseContent<CreatePlayerStreamerSuccess>, Error<CreatePlayerStreamerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let max_duration = params.max_duration;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let video = params.video;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/PlayerStreamers", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = max_duration {
        local_var_form_params.insert("MaxDuration", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = video {
        local_var_form_params.insert("Video", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreatePlayerStreamerSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreatePlayerStreamerError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn create_player_streamer_playback_grant(
    configuration: &configuration::Configuration,
    params: CreatePlayerStreamerPlaybackGrantParams,
) -> Result<
    ResponseContent<CreatePlayerStreamerPlaybackGrantSuccess>,
    Error<CreatePlayerStreamerPlaybackGrantError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let access_control_allow_origin = params.access_control_allow_origin;
    let ttl = params.ttl;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/PlayerStreamers/{Sid}/PlaybackGrant",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = access_control_allow_origin {
        local_var_form_params.insert(
            "AccessControlAllowOrigin",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreatePlayerStreamerPlaybackGrantSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreatePlayerStreamerPlaybackGrantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a MediaRecording resource identified by a SID.
pub async fn delete_media_recording(
    configuration: &configuration::Configuration,
    params: DeleteMediaRecordingParams,
) -> Result<ResponseContent<DeleteMediaRecordingSuccess>, Error<DeleteMediaRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/MediaRecordings/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMediaRecordingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMediaRecordingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a single MediaProcessor resource identified by a SID.
pub async fn fetch_media_processor(
    configuration: &configuration::Configuration,
    params: FetchMediaProcessorParams,
) -> Result<ResponseContent<FetchMediaProcessorSuccess>, Error<FetchMediaProcessorError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/MediaProcessors/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMediaProcessorSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMediaProcessorError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a single MediaRecording resource identified by a SID.
pub async fn fetch_media_recording(
    configuration: &configuration::Configuration,
    params: FetchMediaRecordingParams,
) -> Result<ResponseContent<FetchMediaRecordingSuccess>, Error<FetchMediaRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/MediaRecordings/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMediaRecordingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMediaRecordingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a single PlayerStreamer resource identified by a SID.
pub async fn fetch_player_streamer(
    configuration: &configuration::Configuration,
    params: FetchPlayerStreamerParams,
) -> Result<ResponseContent<FetchPlayerStreamerSuccess>, Error<FetchPlayerStreamerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/PlayerStreamers/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchPlayerStreamerSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchPlayerStreamerError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This method is not enabled.** Returns a single PlaybackGrant resource identified by a SID.
pub async fn fetch_player_streamer_playback_grant(
    configuration: &configuration::Configuration,
    params: FetchPlayerStreamerPlaybackGrantParams,
) -> Result<
    ResponseContent<FetchPlayerStreamerPlaybackGrantSuccess>,
    Error<FetchPlayerStreamerPlaybackGrantError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/PlayerStreamers/{Sid}/PlaybackGrant",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchPlayerStreamerPlaybackGrantSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchPlayerStreamerPlaybackGrantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of MediaProcessors.
pub async fn list_media_processor(
    configuration: &configuration::Configuration,
    params: ListMediaProcessorParams,
) -> Result<ResponseContent<ListMediaProcessorSuccess>, Error<ListMediaProcessorError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let order = params.order;
    let status = params.status;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/MediaProcessors", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order {
        local_var_req_builder =
            local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder =
            local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMediaProcessorSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMediaProcessorError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of MediaRecordings.
pub async fn list_media_recording(
    configuration: &configuration::Configuration,
    params: ListMediaRecordingParams,
) -> Result<ResponseContent<ListMediaRecordingSuccess>, Error<ListMediaRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let order = params.order;
    let status = params.status;
    let processor_sid = params.processor_sid;
    let source_sid = params.source_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/MediaRecordings", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order {
        local_var_req_builder =
            local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder =
            local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = processor_sid {
        local_var_req_builder =
            local_var_req_builder.query(&[("ProcessorSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source_sid {
        local_var_req_builder =
            local_var_req_builder.query(&[("SourceSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMediaRecordingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMediaRecordingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of PlayerStreamers.
pub async fn list_player_streamer(
    configuration: &configuration::Configuration,
    params: ListPlayerStreamerParams,
) -> Result<ResponseContent<ListPlayerStreamerSuccess>, Error<ListPlayerStreamerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let order = params.order;
    let status = params.status;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/PlayerStreamers", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order {
        local_var_req_builder =
            local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder =
            local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListPlayerStreamerSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListPlayerStreamerError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a MediaProcessor resource identified by a SID.
pub async fn update_media_processor(
    configuration: &configuration::Configuration,
    params: UpdateMediaProcessorParams,
) -> Result<ResponseContent<UpdateMediaProcessorSuccess>, Error<UpdateMediaProcessorError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let status = params.status;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/MediaProcessors/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMediaProcessorSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMediaProcessorError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a PlayerStreamer resource identified by a SID.
pub async fn update_player_streamer(
    configuration: &configuration::Configuration,
    params: UpdatePlayerStreamerParams,
) -> Result<ResponseContent<UpdatePlayerStreamerSuccess>, Error<UpdatePlayerStreamerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let status = params.status;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/PlayerStreamers/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdatePlayerStreamerSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdatePlayerStreamerError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
