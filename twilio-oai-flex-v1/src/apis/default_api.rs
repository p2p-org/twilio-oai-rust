/*
 * Twilio - Flex
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.30.0
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for passing parameters to the method [`create_channel`]
#[derive(Clone, Debug, Default)]
pub struct CreateChannelParams {
    /// The chat channel's friendly name.
    pub chat_friendly_name: String,
    /// The chat participant's friendly name.
    pub chat_user_friendly_name: String,
    /// The SID of the Flex Flow.
    pub flex_flow_sid: String,
    /// The `identity` value that uniquely identifies the new resource's chat User.
    pub identity: String,
    /// The chat channel's unique name.
    pub chat_unique_name: Option<String>,
    /// Whether to create the channel as long-lived.
    pub long_lived: Option<bool>,
    /// The pre-engagement data.
    pub pre_engagement_data: Option<String>,
    /// The Target Contact Identity, for example the phone number of an SMS.
    pub target: Option<String>,
    /// The Task attributes to be added for the TaskRouter Task.
    pub task_attributes: Option<String>,
    /// The SID of the TaskRouter Task. Only valid when integration type is `task`. `null` for integration types `studio` & `external`
    pub task_sid: Option<String>,
}

/// struct for passing parameters to the method [`create_flex_flow`]
#[derive(Clone, Debug, Default)]
pub struct CreateFlexFlowParams {
    /// The channel type. One of `web`, `facebook`, `sms`, `whatsapp`, `line` or `custom`. By default, Studioâ€™s Send to Flex widget passes it on to the Task attributes for Tasks created based on this Flex Flow. The Task attributes will be used by the Flex UI to render the respective Task as appropriate (applying channel-specific design and length limits). If `channelType` is `facebook`, `whatsapp` or `line`, the Send to Flex widget should set the Task Channel to Programmable Chat.
    pub channel_type: String,
    /// The SID of the chat service.
    pub chat_service_sid: String,
    /// A descriptive string that you create to describe the Flex Flow resource.
    pub friendly_name: String,
    /// The channel contact's Identity.
    pub contact_identity: Option<String>,
    /// Whether the new Flex Flow is enabled.
    pub enabled: Option<bool>,
    /// The Task Channel SID (TCXXXX) or unique name (e.g., `sms`) to use for the Task that will be created. Applicable and required when `integrationType` is `task`. The default value is `default`.
    pub integration_channel: Option<String>,
    /// In the context of outbound messaging, defines whether to create a Task immediately (and therefore reserve the conversation to current agent), or delay Task creation until the customer sends the first response. Set to false to create immediately, true to delay Task creation. This setting is only applicable for outbound messaging.
    pub integration_creation_on_message: Option<bool>,
    /// The SID of the Studio Flow. Required when `integrationType` is `studio`.
    pub integration_flow_sid: Option<String>,
    /// The Task priority of a new Task. The default priority is 0. Optional when `integrationType` is `task`, not applicable otherwise.
    pub integration_priority: Option<i32>,
    /// The number of times to retry the Studio Flow or webhook in case of failure. Takes integer values from 0 to 3 with the default being 3. Optional when `integrationType` is `studio` or `external`, not applicable otherwise.
    pub integration_retry_count: Option<i32>,
    /// The Task timeout in seconds for a new Task. Default is 86,400 seconds (24 hours). Optional when `integrationType` is `task`, not applicable otherwise.
    pub integration_timeout: Option<i32>,
    /// The URL of the external webhook. Required when `integrationType` is `external`.
    pub integration_url: Option<String>,
    /// The Workflow SID for a new Task. Required when `integrationType` is `task`.
    pub integration_workflow_sid: Option<String>,
    /// The Workspace SID for a new Task. Required when `integrationType` is `task`.
    pub integration_workspace_sid: Option<String>,
    /// The software that will handle inbound messages. [Integration Type](https://www.twilio.com/docs/flex/developer/messaging/manage-flows#integration-types) can be: `studio`, `external`, or `task`.
    pub integration_type: Option<String>,
    /// When enabled, the Messaging Channel Janitor will remove active Proxy sessions if the associated Task is deleted outside of the Flex UI. Defaults to `false`.
    pub janitor_enabled: Option<bool>,
    /// When enabled, Flex will keep the chat channel active so that it may be used for subsequent interactions with a contact identity. Defaults to `false`.
    pub long_lived: Option<bool>,
}

/// struct for passing parameters to the method [`create_interaction`]
#[derive(Clone, Debug, Default)]
pub struct CreateInteractionParams {
    /// The Interaction's channel.
    pub channel: Option<serde_json::Value>,
    /// The Interaction's routing logic.
    pub routing: Option<serde_json::Value>,
}

/// struct for passing parameters to the method [`create_interaction_channel_invite`]
#[derive(Clone, Debug, Default)]
pub struct CreateInteractionChannelInviteParams {
    /// The Interaction SID for this Channel.
    pub interaction_sid: String,
    /// The Channel SID for this Invite.
    pub channel_sid: String,
    /// The Interaction's routing logic.
    pub routing: Option<serde_json::Value>,
}

/// struct for passing parameters to the method [`create_interaction_channel_participant`]
#[derive(Clone, Debug, Default)]
pub struct CreateInteractionChannelParticipantParams {
    /// The Interaction Sid for the new Channel Participant.
    pub interaction_sid: String,
    /// The Channel Sid for the new Channel Participant.
    pub channel_sid: String,
    /// JSON representing the Media Properties for the new Participant.
    pub media_properties: Option<serde_json::Value>,
    /// Participant type.  Can be: `agent`, `customer`, `supervisor`, `external` or `unknown`.
    pub _type: String,
}

/// struct for passing parameters to the method [`create_web_channel`]
#[derive(Clone, Debug, Default)]
pub struct CreateWebChannelParams {
    /// The chat channel's friendly name.
    pub chat_friendly_name: String,
    /// The chat participant's friendly name.
    pub customer_friendly_name: String,
    /// The SID of the Flex Flow.
    pub flex_flow_sid: String,
    /// The chat identity.
    pub identity: String,
    /// The chat channel's unique name.
    pub chat_unique_name: Option<String>,
    /// The pre-engagement data.
    pub pre_engagement_data: Option<String>,
}

/// struct for passing parameters to the method [`delete_channel`]
#[derive(Clone, Debug, Default)]
pub struct DeleteChannelParams {
    /// The SID of the Flex chat channel resource to delete.
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_flex_flow`]
#[derive(Clone, Debug, Default)]
pub struct DeleteFlexFlowParams {
    /// The SID of the Flex Flow resource to delete.
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_web_channel`]
#[derive(Clone, Debug, Default)]
pub struct DeleteWebChannelParams {
    /// The SID of the WebChannel resource to delete.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_channel`]
#[derive(Clone, Debug, Default)]
pub struct FetchChannelParams {
    /// The SID of the Flex chat channel resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_configuration`]
#[derive(Clone, Debug, Default)]
pub struct FetchConfigurationParams {
    /// The Pinned UI version of the Configuration resource to fetch.
    pub ui_version: Option<String>,
}

/// struct for passing parameters to the method [`fetch_flex_flow`]
#[derive(Clone, Debug, Default)]
pub struct FetchFlexFlowParams {
    /// The SID of the Flex Flow resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_interaction`]
#[derive(Clone, Debug, Default)]
pub struct FetchInteractionParams {
    /// The SID of the Interaction resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_interaction_channel`]
#[derive(Clone, Debug, Default)]
pub struct FetchInteractionChannelParams {
    /// The unique string created by Twilio to identify an Interaction resource, prefixed with KD.
    pub interaction_sid: String,
    /// The unique string created by Twilio to identify an Interaction Channel resource, prefixed with UO.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_web_channel`]
#[derive(Clone, Debug, Default)]
pub struct FetchWebChannelParams {
    /// The SID of the WebChannel resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`list_channel`]
#[derive(Clone, Debug, Default)]
pub struct ListChannelParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_flex_flow`]
#[derive(Clone, Debug, Default)]
pub struct ListFlexFlowParams {
    /// The `friendly_name` of the Flex Flow resources to read.
    pub friendly_name: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_interaction_channel`]
#[derive(Clone, Debug, Default)]
pub struct ListInteractionChannelParams {
    /// The unique string created by Twilio to identify an Interaction resource, prefixed with KD.
    pub interaction_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_interaction_channel_invite`]
#[derive(Clone, Debug, Default)]
pub struct ListInteractionChannelInviteParams {
    /// The Interaction SID for this Channel.
    pub interaction_sid: String,
    /// The Channel SID for this Participant.
    pub channel_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_interaction_channel_participant`]
#[derive(Clone, Debug, Default)]
pub struct ListInteractionChannelParticipantParams {
    /// The Interaction Sid for this channel.
    pub interaction_sid: String,
    /// The Channel Sid for this Participant.
    pub channel_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_web_channel`]
#[derive(Clone, Debug, Default)]
pub struct ListWebChannelParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`update_flex_flow`]
#[derive(Clone, Debug, Default)]
pub struct UpdateFlexFlowParams {
    /// The SID of the Flex Flow resource to update.
    pub sid: String,
    /// The channel type. One of `web`, `facebook`, `sms`, `whatsapp`, `line` or `custom`. By default, Studioâ€™s Send to Flex widget passes it on to the Task attributes for Tasks created based on this Flex Flow. The Task attributes will be used by the Flex UI to render the respective Task as appropriate (applying channel-specific design and length limits). If `channelType` is `facebook`, `whatsapp` or `line`, the Send to Flex widget should set the Task Channel to Programmable Chat.
    pub channel_type: Option<String>,
    /// The SID of the chat service.
    pub chat_service_sid: Option<String>,
    /// The channel contact's Identity.
    pub contact_identity: Option<String>,
    /// Whether the new Flex Flow is enabled.
    pub enabled: Option<bool>,
    /// A descriptive string that you create to describe the Flex Flow resource.
    pub friendly_name: Option<String>,
    /// The Task Channel SID (TCXXXX) or unique name (e.g., `sms`) to use for the Task that will be created. Applicable and required when `integrationType` is `task`. The default value is `default`.
    pub integration_channel: Option<String>,
    /// In the context of outbound messaging, defines whether to create a Task immediately (and therefore reserve the conversation to current agent), or delay Task creation until the customer sends the first response. Set to false to create immediately, true to delay Task creation. This setting is only applicable for outbound messaging.
    pub integration_creation_on_message: Option<bool>,
    /// The SID of the Studio Flow. Required when `integrationType` is `studio`.
    pub integration_flow_sid: Option<String>,
    /// The Task priority of a new Task. The default priority is 0. Optional when `integrationType` is `task`, not applicable otherwise.
    pub integration_priority: Option<i32>,
    /// The number of times to retry the Studio Flow or webhook in case of failure. Takes integer values from 0 to 3 with the default being 3. Optional when `integrationType` is `studio` or `external`, not applicable otherwise.
    pub integration_retry_count: Option<i32>,
    /// The Task timeout in seconds for a new Task. Default is 86,400 seconds (24 hours). Optional when `integrationType` is `task`, not applicable otherwise.
    pub integration_timeout: Option<i32>,
    /// The URL of the external webhook. Required when `integrationType` is `external`.
    pub integration_url: Option<String>,
    /// The Workflow SID for a new Task. Required when `integrationType` is `task`.
    pub integration_workflow_sid: Option<String>,
    /// The Workspace SID for a new Task. Required when `integrationType` is `task`.
    pub integration_workspace_sid: Option<String>,
    /// The software that will handle inbound messages. [Integration Type](https://www.twilio.com/docs/flex/developer/messaging/manage-flows#integration-types) can be: `studio`, `external`, or `task`.
    pub integration_type: Option<String>,
    /// When enabled, the Messaging Channel Janitor will remove active Proxy sessions if the associated Task is deleted outside of the Flex UI. Defaults to `false`.
    pub janitor_enabled: Option<bool>,
    /// When enabled, Flex will keep the chat channel active so that it may be used for subsequent interactions with a contact identity. Defaults to `false`.
    pub long_lived: Option<bool>,
}

/// struct for passing parameters to the method [`update_interaction_channel`]
#[derive(Clone, Debug, Default)]
pub struct UpdateInteractionChannelParams {
    /// The unique string created by Twilio to identify an Interaction resource, prefixed with KD.
    pub interaction_sid: String,
    /// The unique string created by Twilio to identify an Interaction Channel resource, prefixed with UO.
    pub sid: String,
    /// Required. Indicates the Interaction channel's status. When a channel is set to `closed`, all tasks are put in the `wrapping` state by default unless the Routing status is set to `closed` in which case the tasks will be `completed`. Value: `closed`.
    pub status: String,
    /// Optional. The state of associated tasks. If not specified, all tasks will be set to `wrapping`.
    pub routing: Option<serde_json::Value>,
}

/// struct for passing parameters to the method [`update_interaction_channel_participant`]
#[derive(Clone, Debug, Default)]
pub struct UpdateInteractionChannelParticipantParams {
    /// The Interaction Sid for this channel.
    pub interaction_sid: String,
    /// The Channel Sid for this Participant.
    pub channel_sid: String,
    /// The unique string created by Twilio to identify an Interaction Channel resource.
    pub sid: String,
    /// The Participant's status. Can be: `closed` or `wrapup`.  Participant must be an agent.
    pub status: String,
}

/// struct for passing parameters to the method [`update_web_channel`]
#[derive(Clone, Debug, Default)]
pub struct UpdateWebChannelParams {
    /// The SID of the WebChannel resource to update.
    pub sid: String,
    /// The chat status. Can only be `inactive`.
    pub chat_status: Option<String>,
    /// The post-engagement data.
    pub post_engagement_data: Option<String>,
}

/// struct for typed successes of method [`create_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelSuccess {
    Status201(crate::models::FlexV1Channel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFlexFlowSuccess {
    Status201(crate::models::FlexV1FlexFlow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_interaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInteractionSuccess {
    Status201(crate::models::FlexV1Interaction),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_interaction_channel_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInteractionChannelInviteSuccess {
    Status201(crate::models::FlexV1InteractionInteractionChannelInteractionChannelInvite),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_interaction_channel_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInteractionChannelParticipantSuccess {
    Status201(crate::models::FlexV1InteractionInteractionChannelInteractionChannelParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWebChannelSuccess {
    Status201(crate::models::FlexV1WebChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFlexFlowSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebChannelSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelSuccess {
    Status200(crate::models::FlexV1Channel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConfigurationSuccess {
    Status200(crate::models::FlexV1Configuration),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFlexFlowSuccess {
    Status200(crate::models::FlexV1FlexFlow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_interaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInteractionSuccess {
    Status200(crate::models::FlexV1Interaction),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_interaction_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInteractionChannelSuccess {
    Status200(crate::models::FlexV1InteractionInteractionChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWebChannelSuccess {
    Status200(crate::models::FlexV1WebChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelSuccess {
    Status200(crate::models::ListChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFlexFlowSuccess {
    Status200(crate::models::ListFlexFlowResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_interaction_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInteractionChannelSuccess {
    Status200(crate::models::ListInteractionChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_interaction_channel_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInteractionChannelInviteSuccess {
    Status200(crate::models::ListInteractionChannelInviteResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_interaction_channel_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInteractionChannelParticipantSuccess {
    Status200(crate::models::ListInteractionChannelParticipantResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWebChannelSuccess {
    Status200(crate::models::ListWebChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFlexFlowSuccess {
    Status200(crate::models::FlexV1FlexFlow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_interaction_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateInteractionChannelSuccess {
    Status200(crate::models::FlexV1InteractionInteractionChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_interaction_channel_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateInteractionChannelParticipantSuccess {
    Status200(crate::models::FlexV1InteractionInteractionChannelInteractionChannelParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWebChannelSuccess {
    Status200(crate::models::FlexV1WebChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFlexFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_interaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInteractionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_interaction_channel_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInteractionChannelInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_interaction_channel_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInteractionChannelParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWebChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFlexFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFlexFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_interaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInteractionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_interaction_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInteractionChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWebChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFlexFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_interaction_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInteractionChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_interaction_channel_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInteractionChannelInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_interaction_channel_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInteractionChannelParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWebChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFlexFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_interaction_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateInteractionChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_interaction_channel_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateInteractionChannelParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWebChannelError {
    UnknownValue(serde_json::Value),
}

///
pub async fn create_channel(
    configuration: &configuration::Configuration,
    params: CreateChannelParams,
) -> Result<ResponseContent<CreateChannelSuccess>, Error<CreateChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_friendly_name = params.chat_friendly_name;
    let chat_user_friendly_name = params.chat_user_friendly_name;
    let flex_flow_sid = params.flex_flow_sid;
    let identity = params.identity;
    let chat_unique_name = params.chat_unique_name;
    let long_lived = params.long_lived;
    let pre_engagement_data = params.pre_engagement_data;
    let target = params.target;
    let task_attributes = params.task_attributes;
    let task_sid = params.task_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Channels", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("ChatFriendlyName", chat_friendly_name.to_string());
    if let Some(local_var_param_value) = chat_unique_name {
        local_var_form_params.insert("ChatUniqueName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("ChatUserFriendlyName", chat_user_friendly_name.to_string());
    local_var_form_params.insert("FlexFlowSid", flex_flow_sid.to_string());
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = long_lived {
        local_var_form_params.insert("LongLived", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = pre_engagement_data {
        local_var_form_params.insert("PreEngagementData", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = target {
        local_var_form_params.insert("Target", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = task_attributes {
        local_var_form_params.insert("TaskAttributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = task_sid {
        local_var_form_params.insert("TaskSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn create_flex_flow(
    configuration: &configuration::Configuration,
    params: CreateFlexFlowParams,
) -> Result<ResponseContent<CreateFlexFlowSuccess>, Error<CreateFlexFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_type = params.channel_type;
    let chat_service_sid = params.chat_service_sid;
    let friendly_name = params.friendly_name;
    let contact_identity = params.contact_identity;
    let enabled = params.enabled;
    let integration_channel = params.integration_channel;
    let integration_creation_on_message = params.integration_creation_on_message;
    let integration_flow_sid = params.integration_flow_sid;
    let integration_priority = params.integration_priority;
    let integration_retry_count = params.integration_retry_count;
    let integration_timeout = params.integration_timeout;
    let integration_url = params.integration_url;
    let integration_workflow_sid = params.integration_workflow_sid;
    let integration_workspace_sid = params.integration_workspace_sid;
    let integration_type = params.integration_type;
    let janitor_enabled = params.janitor_enabled;
    let long_lived = params.long_lived;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/FlexFlows", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("ChannelType", channel_type.to_string());
    local_var_form_params.insert("ChatServiceSid", chat_service_sid.to_string());
    if let Some(local_var_param_value) = contact_identity {
        local_var_form_params.insert("ContactIdentity", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = enabled {
        local_var_form_params.insert("Enabled", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = integration_channel {
        local_var_form_params.insert("Integration.Channel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_creation_on_message {
        local_var_form_params.insert(
            "Integration.CreationOnMessage",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = integration_flow_sid {
        local_var_form_params.insert("Integration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_priority {
        local_var_form_params.insert("Integration.Priority", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_retry_count {
        local_var_form_params.insert("Integration.RetryCount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_timeout {
        local_var_form_params.insert("Integration.Timeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_url {
        local_var_form_params.insert("Integration.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_workflow_sid {
        local_var_form_params.insert("Integration.WorkflowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_workspace_sid {
        local_var_form_params.insert(
            "Integration.WorkspaceSid",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = integration_type {
        local_var_form_params.insert("IntegrationType", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = janitor_enabled {
        local_var_form_params.insert("JanitorEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = long_lived {
        local_var_form_params.insert("LongLived", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateFlexFlowSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateFlexFlowError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Interaction.
pub async fn create_interaction(
    configuration: &configuration::Configuration,
    params: CreateInteractionParams,
) -> Result<ResponseContent<CreateInteractionSuccess>, Error<CreateInteractionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel = params.channel;
    let routing = params.routing;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Interactions", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    match channel {
        Some(local_var_param_value) => {
            local_var_form_params.insert("Channel", local_var_param_value.to_string());
        }
        None => {
            local_var_form_params.insert("Channel", "");
        }
    }
    match routing {
        Some(local_var_param_value) => {
            local_var_form_params.insert("Routing", local_var_param_value.to_string());
        }
        None => {
            local_var_form_params.insert("Routing", "");
        }
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateInteractionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateInteractionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Invite an Agent or a TaskQueue to a Channel.
pub async fn create_interaction_channel_invite(
    configuration: &configuration::Configuration,
    params: CreateInteractionChannelInviteParams,
) -> Result<
    ResponseContent<CreateInteractionChannelInviteSuccess>,
    Error<CreateInteractionChannelInviteError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let interaction_sid = params.interaction_sid;
    let channel_sid = params.channel_sid;
    let routing = params.routing;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Invites",
        local_var_configuration.base_path,
        InteractionSid = crate::apis::urlencode(interaction_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    match routing {
        Some(local_var_param_value) => {
            local_var_form_params.insert("Routing", local_var_param_value.to_string());
        }
        None => {
            local_var_form_params.insert("Routing", "");
        }
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateInteractionChannelInviteSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateInteractionChannelInviteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a Participant to a Channel.
pub async fn create_interaction_channel_participant(
    configuration: &configuration::Configuration,
    params: CreateInteractionChannelParticipantParams,
) -> Result<
    ResponseContent<CreateInteractionChannelParticipantSuccess>,
    Error<CreateInteractionChannelParticipantError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let interaction_sid = params.interaction_sid;
    let channel_sid = params.channel_sid;
    let media_properties = params.media_properties;
    let _type = params._type;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Participants",
        local_var_configuration.base_path,
        InteractionSid = crate::apis::urlencode(interaction_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    match media_properties {
        Some(local_var_param_value) => {
            local_var_form_params.insert("MediaProperties", local_var_param_value.to_string());
        }
        None => {
            local_var_form_params.insert("MediaProperties", "");
        }
    }
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateInteractionChannelParticipantSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateInteractionChannelParticipantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn create_web_channel(
    configuration: &configuration::Configuration,
    params: CreateWebChannelParams,
) -> Result<ResponseContent<CreateWebChannelSuccess>, Error<CreateWebChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_friendly_name = params.chat_friendly_name;
    let customer_friendly_name = params.customer_friendly_name;
    let flex_flow_sid = params.flex_flow_sid;
    let identity = params.identity;
    let chat_unique_name = params.chat_unique_name;
    let pre_engagement_data = params.pre_engagement_data;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/WebChannels", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("ChatFriendlyName", chat_friendly_name.to_string());
    if let Some(local_var_param_value) = chat_unique_name {
        local_var_form_params.insert("ChatUniqueName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("CustomerFriendlyName", customer_friendly_name.to_string());
    local_var_form_params.insert("FlexFlowSid", flex_flow_sid.to_string());
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = pre_engagement_data {
        local_var_form_params.insert("PreEngagementData", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateWebChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateWebChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn delete_channel(
    configuration: &configuration::Configuration,
    params: DeleteChannelParams,
) -> Result<ResponseContent<DeleteChannelSuccess>, Error<DeleteChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Channels/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn delete_flex_flow(
    configuration: &configuration::Configuration,
    params: DeleteFlexFlowParams,
) -> Result<ResponseContent<DeleteFlexFlowSuccess>, Error<DeleteFlexFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/FlexFlows/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteFlexFlowSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteFlexFlowError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn delete_web_channel(
    configuration: &configuration::Configuration,
    params: DeleteWebChannelParams,
) -> Result<ResponseContent<DeleteWebChannelSuccess>, Error<DeleteWebChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/WebChannels/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteWebChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteWebChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn fetch_channel(
    configuration: &configuration::Configuration,
    params: FetchChannelParams,
) -> Result<ResponseContent<FetchChannelSuccess>, Error<FetchChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Channels/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn fetch_configuration(
    configuration: &configuration::Configuration,
    params: FetchConfigurationParams,
) -> Result<ResponseContent<FetchConfigurationSuccess>, Error<FetchConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ui_version = params.ui_version;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Configuration", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ui_version {
        local_var_req_builder =
            local_var_req_builder.query(&[("UiVersion", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConfigurationSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConfigurationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn fetch_flex_flow(
    configuration: &configuration::Configuration,
    params: FetchFlexFlowParams,
) -> Result<ResponseContent<FetchFlexFlowSuccess>, Error<FetchFlexFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/FlexFlows/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFlexFlowSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFlexFlowError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn fetch_interaction(
    configuration: &configuration::Configuration,
    params: FetchInteractionParams,
) -> Result<ResponseContent<FetchInteractionSuccess>, Error<FetchInteractionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Interactions/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchInteractionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchInteractionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a Channel for an Interaction.
pub async fn fetch_interaction_channel(
    configuration: &configuration::Configuration,
    params: FetchInteractionChannelParams,
) -> Result<ResponseContent<FetchInteractionChannelSuccess>, Error<FetchInteractionChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let interaction_sid = params.interaction_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Interactions/{InteractionSid}/Channels/{Sid}",
        local_var_configuration.base_path,
        InteractionSid = crate::apis::urlencode(interaction_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchInteractionChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchInteractionChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn fetch_web_channel(
    configuration: &configuration::Configuration,
    params: FetchWebChannelParams,
) -> Result<ResponseContent<FetchWebChannelSuccess>, Error<FetchWebChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/WebChannels/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWebChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWebChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn list_channel(
    configuration: &configuration::Configuration,
    params: ListChannelParams,
) -> Result<ResponseContent<ListChannelSuccess>, Error<ListChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Channels", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn list_flex_flow(
    configuration: &configuration::Configuration,
    params: ListFlexFlowParams,
) -> Result<ResponseContent<ListFlexFlowSuccess>, Error<ListFlexFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/FlexFlows", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFlexFlowSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFlexFlowError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all Channels for an Interaction.
pub async fn list_interaction_channel(
    configuration: &configuration::Configuration,
    params: ListInteractionChannelParams,
) -> Result<ResponseContent<ListInteractionChannelSuccess>, Error<ListInteractionChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let interaction_sid = params.interaction_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Interactions/{InteractionSid}/Channels",
        local_var_configuration.base_path,
        InteractionSid = crate::apis::urlencode(interaction_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListInteractionChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListInteractionChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all Invites for a Channel.
pub async fn list_interaction_channel_invite(
    configuration: &configuration::Configuration,
    params: ListInteractionChannelInviteParams,
) -> Result<
    ResponseContent<ListInteractionChannelInviteSuccess>,
    Error<ListInteractionChannelInviteError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let interaction_sid = params.interaction_sid;
    let channel_sid = params.channel_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Invites",
        local_var_configuration.base_path,
        InteractionSid = crate::apis::urlencode(interaction_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListInteractionChannelInviteSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListInteractionChannelInviteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all Participants for a Channel.
pub async fn list_interaction_channel_participant(
    configuration: &configuration::Configuration,
    params: ListInteractionChannelParticipantParams,
) -> Result<
    ResponseContent<ListInteractionChannelParticipantSuccess>,
    Error<ListInteractionChannelParticipantError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let interaction_sid = params.interaction_sid;
    let channel_sid = params.channel_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Participants",
        local_var_configuration.base_path,
        InteractionSid = crate::apis::urlencode(interaction_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListInteractionChannelParticipantSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListInteractionChannelParticipantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn list_web_channel(
    configuration: &configuration::Configuration,
    params: ListWebChannelParams,
) -> Result<ResponseContent<ListWebChannelSuccess>, Error<ListWebChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/WebChannels", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListWebChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListWebChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn update_flex_flow(
    configuration: &configuration::Configuration,
    params: UpdateFlexFlowParams,
) -> Result<ResponseContent<UpdateFlexFlowSuccess>, Error<UpdateFlexFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let channel_type = params.channel_type;
    let chat_service_sid = params.chat_service_sid;
    let contact_identity = params.contact_identity;
    let enabled = params.enabled;
    let friendly_name = params.friendly_name;
    let integration_channel = params.integration_channel;
    let integration_creation_on_message = params.integration_creation_on_message;
    let integration_flow_sid = params.integration_flow_sid;
    let integration_priority = params.integration_priority;
    let integration_retry_count = params.integration_retry_count;
    let integration_timeout = params.integration_timeout;
    let integration_url = params.integration_url;
    let integration_workflow_sid = params.integration_workflow_sid;
    let integration_workspace_sid = params.integration_workspace_sid;
    let integration_type = params.integration_type;
    let janitor_enabled = params.janitor_enabled;
    let long_lived = params.long_lived;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/FlexFlows/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel_type {
        local_var_form_params.insert("ChannelType", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = chat_service_sid {
        local_var_form_params.insert("ChatServiceSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = contact_identity {
        local_var_form_params.insert("ContactIdentity", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = enabled {
        local_var_form_params.insert("Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_channel {
        local_var_form_params.insert("Integration.Channel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_creation_on_message {
        local_var_form_params.insert(
            "Integration.CreationOnMessage",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = integration_flow_sid {
        local_var_form_params.insert("Integration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_priority {
        local_var_form_params.insert("Integration.Priority", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_retry_count {
        local_var_form_params.insert("Integration.RetryCount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_timeout {
        local_var_form_params.insert("Integration.Timeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_url {
        local_var_form_params.insert("Integration.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_workflow_sid {
        local_var_form_params.insert("Integration.WorkflowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_workspace_sid {
        local_var_form_params.insert(
            "Integration.WorkspaceSid",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = integration_type {
        local_var_form_params.insert("IntegrationType", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = janitor_enabled {
        local_var_form_params.insert("JanitorEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = long_lived {
        local_var_form_params.insert("LongLived", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateFlexFlowSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateFlexFlowError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing Interaction.
pub async fn update_interaction_channel(
    configuration: &configuration::Configuration,
    params: UpdateInteractionChannelParams,
) -> Result<ResponseContent<UpdateInteractionChannelSuccess>, Error<UpdateInteractionChannelError>>
{
    let local_var_configuration = configuration;

    // unbox the parameters
    let interaction_sid = params.interaction_sid;
    let sid = params.sid;
    let status = params.status;
    let routing = params.routing;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Interactions/{InteractionSid}/Channels/{Sid}",
        local_var_configuration.base_path,
        InteractionSid = crate::apis::urlencode(interaction_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = routing {
        local_var_form_params.insert("Routing", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateInteractionChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateInteractionChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing Channel Participant.
pub async fn update_interaction_channel_participant(
    configuration: &configuration::Configuration,
    params: UpdateInteractionChannelParticipantParams,
) -> Result<
    ResponseContent<UpdateInteractionChannelParticipantSuccess>,
    Error<UpdateInteractionChannelParticipantError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let interaction_sid = params.interaction_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let status = params.status;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Participants/{Sid}",
        local_var_configuration.base_path,
        InteractionSid = crate::apis::urlencode(interaction_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateInteractionChannelParticipantSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateInteractionChannelParticipantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn update_web_channel(
    configuration: &configuration::Configuration,
    params: UpdateWebChannelParams,
) -> Result<ResponseContent<UpdateWebChannelSuccess>, Error<UpdateWebChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let chat_status = params.chat_status;
    let post_engagement_data = params.post_engagement_data;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/WebChannels/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = chat_status {
        local_var_form_params.insert("ChatStatus", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = post_engagement_data {
        local_var_form_params.insert("PostEngagementData", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateWebChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateWebChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
